#!/usr/bin/env python3

"""postprocessing of an alphafold2 run"""

from __future__ import annotations

from typing import Any, Optional, TypedDict, cast
from collections.abc import Iterable, Sequence
import pickle
import os
import sys
import glob
import json
from pathlib import Path
from string import ascii_uppercase, ascii_lowercase

import matplotlib.pyplot as plt
from matplotlib.figure import Figure
import numpy
from alphafold_postprocessing.utils import load_pkl

try:
    from pymol import cmd as pymol_cmd

    HAVE_PYMOL = True
except ImportError:
    HAVE_PYMOL = False


__version__ = "1.0.0"


class PredictionResult(TypedDict):
    """Prediction result data structure generated by alphafold."""

    plddt: Any
    distogram: dict[str, Any]
    predicted_aligned_error: Any


def main(
    data_dir: Path,
    features: Optional[dict[str, Any]],
    out_dir: Optional[Path],
) -> None:
    """Main function"""

    data = list(load_prediction_results(data_dir))
    seq_length: Optional[int] = (
        features.get("seq_length") if features is not None else None
    )
    figs: tuple[tuple[str, Figure], ...] = (
        ("pLDDT", plot_plddt(data)),
        ("distogram", plot_distogram(data)),
        ("paes", plot_paes(data, seq_length) if seq_length is not None else None),
    )

    if out_dir is not None:
        os.makedirs(out_dir, exist_ok=True)
        for label, fig in figs:
            if fig is not None:
                fig.savefig(out_dir / (label + ".svg"))
                print("Figures have been saved.")
        if HAVE_PYMOL:
            for pdb in glob.glob(os.path.join(data_dir, "*relaxed_*.pdb")):
                plot_structure(Path(pdb), out_dir / (Path(pdb).stem + ".png"))
    else:
        plt.show()




def load_prediction_result(path: Path) -> PredictionResult:
    """Load a single pkl file as a PredictionResult"""
    return cast(PredictionResult, load_pkl(path))


def load_prediction_results(path: Path) -> Iterable[tuple[str, PredictionResult]]:
    """Load output pkls from a folder"""

    print("Loading prediction results")

    try:
        with open(path / "ranking_debug.json", "rb") as f:
            ranking = json.load(f)
        
        print("Ranking data loaded successfully")
        
        # Determine total number of items to process
        total_items = len(ranking["order"])
        processed_items = 0

        # Check if all expected .pkl files exist
        missing_files = []
        for stem in ranking["order"]:
            pkl_file = path / f"result_{stem}.pkl"
            if not pkl_file.exists():
                missing_files.append(f"result_{stem}.pkl")

        if missing_files:
            print("Warning: The following .pkl files are missing:")
            for missing_file in missing_files:
                print(f"- {missing_file}")
        else:
            print("All expected .pkl files are present.")

        # Iterate through ranking data and load corresponding prediction results
        for n, stem in enumerate(ranking["order"], start=1):
            processed_items += 1
            print(f"Loading result {processed_items}/{total_items}")
            yield f"Rank {n}", load_prediction_result(path / f"result_{stem}.pkl")

    except FileNotFoundError as e:
        print(f"Warning: Ranking file not found: {e}. Using file name labels.")
    except Exception as e:
        print(f"Error occurred while loading ranking data: {e}")

    # If there's an error or no ranking file, fall back to loading individual files
    print("Loading individual prediction results")

    return (
        (
            os.path.basename(pkl_path).removeprefix("result_").removesuffix(".pkl"),
            load_prediction_result(Path(pkl_path)),
        )
        for pkl_path in sorted(glob.glob(os.path.join(path, "result_*.pkl")))
    )


def plot_plddt(models: Iterable[tuple[str, PredictionResult]]) -> Figure:
    """Generate svg outputs for pLDDT"""
    print("Generating plDDT plot")
    fig = plt.figure(figsize=(10, 6), dpi=100)

    for label, model in models:
        plt.plot(model["plddt"], label=label)

    plt.xlabel("residue nr.")
    plt.ylabel("pLDDT score")
    plt.legend()
    return fig


def plot_distogram(models: Sequence[tuple[str, PredictionResult]]) -> Figure:
    """Generate svg distogram"""
    print("Generating distogram")
    fig = plt.figure(figsize=(3 * len(models), 2))
    for n, (label, model) in enumerate(models, start=1):
        plt.subplot(1, len(models), n)
        plt.title(label)
        dist_bins = numpy.argmax(expit(model["distogram"]["logits"]), axis=-1)
        # bins to Å (63 bins from 2 Å to 22 Å):
        dist = 2.0 + dist_bins / 63.0 * 20.0
        plt.imshow(dist)
        cbar = plt.colorbar()
    # Label only the last one:
    cbar.ax.set_ylabel("Distance [Å]")

    return fig


def expit(x: Any) -> Any:
    """expit function"""
    out = numpy.empty_like(x)
    x_negative = x < 0.0
    out[~x_negative] = 1.0 / (1.0 + numpy.exp(-x[~x_negative]))
    e_x = numpy.exp(x[x_negative])
    out[x_negative] = e_x / (1.0 + e_x)
    return out


def plot_paes(
    models: Iterable[tuple[str, PredictionResult]],
    seq_len: int,
    Ls: Optional[list[int]] = None,
) -> Optional[Figure]:
    """Plot predicted aligned error"""
    print("Plot predicted aligned error")
    models = [(m_name, m) for m_name, m in models if "predicted_aligned_error" in m]
    if not models:
        return None
    num_models = len(models)
    fig = plt.figure(figsize=(3 * num_models, 2))
    paes = (
        (label, model["predicted_aligned_error"][:seq_len][:seq_len])
        for label, model in models
    )
    for n, (label, pae) in enumerate(paes):
        plt.subplot(1, num_models, n + 1)
        plt.title(label)
        Ln = pae.shape[0]
        plt.imshow(pae, cmap="bwr", vmin=0, vmax=30, extent=(0, Ln, Ln, 0))
        if Ls is not None and len(Ls) > 1:
            plot_ticks(Ls)
        plt.colorbar()
    return fig


def plot_ticks(Ls: list[int]) -> None:
    """Plot ticks in a paes plot"""
    alphabet_list = list(ascii_uppercase + ascii_lowercase)
    Ln = sum(Ls)
    L_prev = 0
    for L_i in Ls[:-1]:
        L = L_prev + L_i
        L_prev += L_i
        plt.plot([0, Ln], [L, L], color="black")
        plt.plot([L, L], [0, Ln], color="black")
    ticks = numpy.cumsum([0] + Ls)
    ticks = (ticks[1:] + ticks[:-1]) / 2
    plt.yticks(ticks, alphabet_list[: len(ticks)])


def plot_structure(pdb_path: Path, out_path: Path) -> None:
    """Display 3D structure"""
    pymol_cmd.load(str(pdb_path))
    pymol_cmd.spectrum("b", "red_white_blue", "*", 0, 100)
    pymol_cmd.show("cartoon")
    pymol_cmd.hide("lines", "all")
    pymol_cmd.set("depth_cue", 0)
    pymol_cmd.set("spec_reflect", 0)
    pymol_cmd.set("bg_rgb", [1, 1, 1])
    pymol_cmd.set("orthoscopic", "on")
    pymol_cmd.set("cartoon_fancy_helices", 1)
    pymol_cmd.set("cartoon_smooth_loops", 1)
    pymol_cmd.set("cartoon_highlight_color", 1)
    pymol_cmd.set("cartoon_loop_radius", 0.5)
    pymol_cmd.set("ray_shadows", 0)
    pymol_cmd.set("ray_texture", 1)
    pymol_cmd.ray()
    pymol_cmd.png(str(out_path))


